esphome:
  name: lora_receiver
  platform: ESP32
  board: esp32dev

external_components:
  - source: github://cybermatte/esphome-hardware-aes-cbc

logger:

globals:
  - id: aes_key_str
    type: std::string
    initial_value: "mysecretkey123"
  - id: hmac_key_str
    type: std::string
    initial_value: "anothersecretkey456"

esphome:
  on_boot:
    priority: -100
    then:
      - lambda: |-
          auto aes = new esphome::hardware_aes::HardwareAESCBCComponent();
          aes->set_key_from_string(id(aes_key_str), 16);       // AES-128
          aes->set_hmac_key_from_string(id(hmac_key_str), 32); // HMAC-256
          App.register_component(aes);


spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO19

lora:
  cs_pin: GPIO5
  reset_pin: GPIO14
  dio0_pin: GPIO26
  frequency: 915MHz
  id: lora

custom_component:
  - lambda: |-
      auto aes = new HardwareAESCBCComponent();
      App.register_component(aes);

      id(lora).on_packet([](std::vector<uint8_t> data) {
        if (data.size() < 16) {
          ESP_LOGW("receiver", "Packet too short");
          return;
        }

        std::vector<uint8_t> iv(data.begin(), data.begin() + 16);
        std::vector<uint8_t> encrypted(data.begin() + 16, data.end());
        std::vector<uint8_t> decrypted;

        if (!aes->decrypt_cbc_with_hmac(encrypted, decrypted, iv.data())) {
          ESP_LOGW("receiver", "Decryption failed or HMAC mismatch");
          return;
        }

        uint8_t device_id = decrypted[0];
        uint8_t counter = decrypted[1];
        float temperature = decrypted[2] / 10.0;
        float humidity = decrypted[3];
        float pressure = decrypted[4] * 10.0;

        ESP_LOGI("receiver", "Device %d | Count %d | Temp %.1fÂ°C | Hum %.1f%% | Pressure %.1f hPa",
                 device_id, counter, temperature, humidity, pressure);
      });
