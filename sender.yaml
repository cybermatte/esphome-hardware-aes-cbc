esphome:
  name: lora_sender
  platform: ESP32
  board: esp32dev

# 🧠 AES & HMAC Keys
globals:
  - id: aes_key_str
    type: std::string
    initial_value: "mysecretkey123"
  - id: hmac_key_str
    type: std::string
    initial_value: "anothersecretkey456"
  - id: aes_component
    type: esphome::hardware_aes::HardwareAESCBCComponent*
    restore_value: no
    initial_value: "nullptr"

# 🔐 Register AES component on boot
on_boot:
  priority: -100
  then:
    - lambda: |-
        auto aes = new esphome::hardware_aes::HardwareAESCBCComponent();
        aes->set_key_from_string(id(aes_key_str), 16);       // AES-128
        aes->set_hmac_key_from_string(id(hmac_key_str), 32); // HMAC-256
        App.register_component(aes);
        id(aes_component) = aes;

external_components:
  - source: github://cybermatte/esphome-hardware-aes-cbc

logger:

# 🌡️ BME280 Sensor
i2c:
  sda: GPIO21
  scl: GPIO22

sensor:
  - platform: bme280
    temperature:
      name: "BME280 Temperature"
      id: temp_bme
    pressure:
      name: "BME280 Pressure"
      id: pressure_bme
    humidity:
      name: "BME280 Humidity"
      id: humidity_bme
    address: 0x76
    update_interval: 60s

# 📡 LoRa Radio (SX127x)
spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO19

lora:
  cs_pin: GPIO5
  reset_pin: GPIO14
  dio0_pin: GPIO26
  frequency: 915MHz
  id: lora

# 📦 Custom Component to Encrypt and Send Payload
custom_component:
  - lambda: |-
      static uint8_t counter = 0;

      std::vector<uint8_t> payload = {
        0x01,  // Device ID
        counter++,
        (uint8_t)(id(temp_bme).state * 10),
        (uint8_t)(id(humidity_bme).state),
        (uint8_t)(id(pressure_bme).state / 10)
      };

      std::vector<uint8_t> encrypted;
      uint8_t iv[16];
      id(aes_component)->encrypt_cbc_with_hmac(payload, encrypted, iv);

      std::vector<uint8_t> packet(iv, iv + 16);
      packet.insert(packet.end(), encrypted.begin(), encrypted.end());

      id(lora).send_packet(packet);
      ESP_LOGI("sender", "Encrypted sensor packet sent");
      return {};
    update_interval: 60s
